<!doctype>
<head>
<style>
body{
  padding:0;
  margin:0;
  margin-top:60px;
}
.graph{
  /*width:650px;
  height: 300px;*/
  display:inline-block;
  margin-bottom: 10px;
}
.bt-group{
  border-right: 1px solid #ccc;
  margin-right: 10px;
  padding-right: 8px;
}
.bt-group-end{
  border-right: 0px;
}
#controls{
  background-color:#f9f9f9;
  border-bottom: 1px solid lightgray;
  margin-bottom: 10px;
  top:0;
  width:100%;
  position: fixed;
  z-index:1000;
  padding:5px;
}
#title{
  font-size: 38px;
  vertical-align: sub;
  float: left;
  padding-left: 4px;
}
#buttons {
  float:right;
  margin-top:18px;
}
.graph-container{
  display:inline-block;
  text-align:right;
  border:1px solid #ccc;
  margin: 10px;
  padding:10px;
}
.legend{
}
</style>
<script src="http://dygraphs.com/dygraph-dev.js"></script>
<script type="text/javascript" src="http://www.google.com/jsapi"></script>
<script type="text/javascript">
  //google.load('visualization', '1', {packages: ['gauge']});
  google.load('jquery', '1.7.0');
</script>
</head>
<body>

<div id="controls">
<span id="title"></span>
<span id="buttons">
<span class="bt-group">
<input type="checkbox" id="ct-update" checked=checked onclick="toggleUpdates()">Live updates</input>
<input type="checkbox" checked=checked id="ct-sync-graphs" onclick="toggleSync()">Sync zooms</input>
</span>

<span class="bt-group">
Zoom:
<button onclick="setLast(24*60*60)">-1d</button>
<button onclick="setLast(60*60)">-1h</button>
<button onclick="setLast(15*60)">-15m</button>
<button onclick="setLast(60)">-60s</button>
</span>

<span class="bt-group">
Load:
<button onclick="loadMore(365*24*60*60, '43200s')">1y</button>
<button onclick="loadMore(31*24*60*60, '3600s')">1m</button>
<button onclick="loadMore(7*24*60*60, '600s')">1w</button>
<button onclick="loadMore(24*60*60, '60s')">1d</button>
<button onclick="loadMore(60*60, '15s')">1h</button>
</span>

<span class="bt-group">
View Fetch:
<button onclick="loadFromZoom(false)">Avg</button>
<button onclick="loadFromZoom(true)">Full</button>
</span>

<span class="bt-group bt-group-end">
<button onclick="shareView()">Share view</button>
</span>
</span>
</div>

<div id="graphs">
</div>

<script>
// Default options.
var opts = {
  graphite_url: '',

  namespace: '',
  dashboard: 'ycoppel1',
  test_metric: '',

  sync_graphs: true,
  live_updates: true,
  initial_fetch: '-3s',

  graph_width: '640',
  graph_height: '300',

  // Preloading
  from: 0,
  to: 0,
  full_res_preload: false,
};

// State stuff.
var all_graphs = [];
var first = Math.ceil(new Date().valueOf() / 1000);
var last = Math.ceil(new Date().valueOf() / 1000);
var min_freq = 60;
// Dygraph -> object{g, targets, data}
var graphs = [];
// target -> true
var all_targets = {};
var timer = null;
var blockRedraw = false;

function drawCallback(me, initial) {
  if (blockRedraw || initial || !opts.sync_graphs) return;
  blockRedraw = true;
  var range = me.xAxisRange();
  for (var gi in graphs) {
    var g = graphs[gi];
    if (g.g == me) continue;
    g.g.updateOptions({
      dateWindow: range,
    });
  }
  blockRedraw = false;
}

function mkgraph(els, targets, title) {
  var labels = ['x'];
  for (var t in targets) {
    labels.push(targets[t]);
    all_targets[targets[t]] = true;
  }
  var g = new Dygraph(els.graph, [], {
    labels: labels,
    animatedZooms: true,
    panEdgeFraction: 0,
    drawCallback: drawCallback,
    legend: 'always',
    labelsDiv: els.legend,
    title: title,
    width: opts.graph_width,
    height: opts.graph_height,
    //showRangeSelector: true,
    //rangeSelectorHeight: 30,
    //strokeBorderWidth: 2,
    //strokeBorderColor: 'black',
  });
  all_graphs.push(g);
  graphs.push({
    g: g,
    targets: targets,
    data: [],
    data_by_date: {},
  });
}

function pollUrl(from, to, summarize) {
  if (Object.keys(all_targets).length == 0) {
    return null;
  }
  var left = 0;
  if (from) {
    left = from;
  } else {
    left = last - min_freq;
  }
  var maybe_to = '';
  if (to != undefined) {
    maybe_to = '&until=' + to;
  }

  var targets_q = "";
  for (var k in all_targets) {
    k = addNamespaceToTarget(k);
    if (!summarize) {
      targets_q += "&target=" + k;
    } else {
      targets_q += "&target=" +
        encodeURIComponent(
            "summarize(" + k + ", \"" + summarize + "\", \"avg\")");
    }
  }
  return opts.graphite_url + '/render/?' +
    'from=' + left + maybe_to +
    targets_q + '&drawNullAsZero=false&noCache=true&format=json&jsonp=?';
}

function update(url) {
  timer = null;
  var start_update = new Date().valueOf();
  var bye = function() {
    var end_update = new Date().valueOf();
    setupUpdates(1000 - (end_update - start_update));
  }

  if (!url) url = pollUrl();
  if (!url) {
    bye();
    return;
  }
  $.ajax({
    url: url,
		dataType: 'jsonp',
		success: function(d) {
      var prev_last = last;
      // Extract all the data by date
      var new_data = {};
      for (var i = 0; i < d.length; ++i) {
        var series = d[i];
        var name = series.target;
        var is_summary = name.match(/summarize\(([\w.-]*), .*\)/);
        if (is_summary) {
          name = is_summary[1];
        }
        name = removeNamespaceFromTarget(name);
        var points = series.datapoints;
        var ny = [];
        for (var pi = 0; pi < points.length; ++pi) {
          var ts = points[pi][1];
          var val = points[pi][0];
          ny.push([ts, val]);
          if (ts > last) {
            last = ts;
          }
          if (ts < first) {
            first = ts;
          }
        }
        new_data[name] = ny;
      }

      rebuildGraphs(new_data, prev_last);
      bye();
    },
    error: function(e) {
      console.log("ERROR");
      console.log(e);
      bye();
    },
  });
}

// new_data is series_name -> ts -> val
function rebuildGraphs(new_data, append_from) {
  for (var gi in graphs) {
    var obj = graphs[gi];
    var g = obj.g;
    var targets = obj.targets;

    // Update the data by date for this graph.
    // ts -> name -> val
    var data_by_date = {};
    for (var ti in targets) {
      var name = targets[ti];
      var series = new_data[name];
      for (var si in series) {
        var ts = series[si][0];
        var val = series[si][1];
        var x = data_by_date[ts];
        if (!x) { x = {}; }
        x[name] = val;
        data_by_date[ts] = x;
      }
    }

    //console.log('now building final array from', data_by_date);
    // Build the list of points from the dictionary.
    graph_data = [];
    for (var ts in data_by_date) {
      var entry = [ new Date(ts * 1000) ];
      for (var n in targets) {
        entry.push(data_by_date[ts][targets[n]]);
      }
      setInDataArray(graph_data, entry[0], entry);
    }
    if (graph_data.length != 0) {
      //console.log("Content", obj.data);
      //console.log("Start", graph_data);
      var start_replace = findSplitPoint(obj.data, graph_data[0][0]);
      var end_replace = findSplitPoint(obj.data, graph_data[graph_data.length - 1][0]);
      //console.log(start_replace, end_replace);
      obj.data =
        obj.data.slice(0, start_replace).concat(
            graph_data).concat(obj.data.slice(end_replace + 1));
      //console.log("Result:", obj.data);
    }

    // Update the graph.
    var opts = {'file': obj.data};
    var win = g.xAxisRange();
    var win_to_last = win[1] - (append_from * 1000);
    var following = g.isZoomed('x') && win_to_last > -5000;//< 1000 && win_to_last > -1000;
    if (following) {
      if (win_to_last < 0) win_to_last = 0;
      // Move the window.
      var head = last * 1000 + win_to_last;
      opts['dateWindow'] = [head - win[1] + win[0], head];
    }
    blockRedraw = true;
    g.updateOptions(opts);
    blockRedraw = false;
  }
}

function findSplitPoint(ar, ts) {
  function findTsInternal(ar, start, end) {
    var pivot = Math.floor(start + (end - start) / 2);
    if (end == start) {
      return pivot;
    }
    if(end-start == 1) {
      if (ar[start] && ar[start][0].valueOf() == ts.valueOf()) {
        return start;
      }
      if (ar[end] && ar[end][0].valueOf() == ts.valueOf()) {
        return end;
      }
      return pivot;
    } else if(ar[pivot][0].valueOf() < ts.valueOf()) {
      return findTsInternal(ar, pivot, end);
    } else {
      return findTsInternal(ar, start, pivot);
    }
  }
  return findTsInternal(ar, 0, ar.length);
}

function setInDataArray(ar, ts, ts_val) {
  // First, shortcuts, as these are 2 very common operations:
  if (ar[ar.length-1] &&
      ar[ar.length-1][0].valueOf() < ts_val[0].valueOf()) {
    ar.push(ts_val);
    return;
  }
  if (ar[0] && ar[0][0].valueOf() > ts_val[0].valueOf()) {
    ar.unshift(ts_val);
    return;
  }

  function cp(from, to) {
    for (var i in from) {
      to[i] = from[i];
    }
  }
  function findTs(ar, start, end) {
    var pivot = Math.floor(start + (end - start) / 2);
    if(end-start <= 1) {
      if (ar[pivot + 1]) {
        if (ar[pivot + 1][0].valueOf() == ts.valueOf()) {
          cp(ts_val, ar[pivot + 1]);
          return ar;
        }
      }
      ar.splice(pivot + 1, 0, ts_val);
      return ar;
    }
    if (ar[pivot][0] == ts) {
      ar[pivot] = ts_val;
      return ar;
    } else if(ar[pivot][0] < ts) {
      return findTs(ar, pivot, end);
    } else {
      return findTs(ar, start, pivot);
    }
  }

  return findTs(ar, 0, ar.length);
}

function toggleUpdates() {
  var c = document.getElementById('ct-update');
  opts.live_updates = c.checked;
  setupUpdates();
}

function setupUpdates(ms) {
  if (opts.live_updates) {
    if (!timer) {
      ms = ms != undefined ? ms : 1000;
      if (ms < 100) {
        // Still use a timout, so we don't grow the call stack
        // constantly, and dont' overload the server.
        ms = 100
      }
      timer = setTimeout(update, ms);
    }
  } else if (timer) {
    console.log("unset");
    clearTimeout(timer);
    timer = null;
  }
}

function toggleSync() {
  var c = document.getElementById('ct-sync-graphs');
  opts.sync_graphs = c.checked;
  if (opts.sync_graphs) {
    drawCallback(graphs[0].g, false);
  }
}

function setLast(secs) {
  var now = new Date().valueOf();
  var left = (now - secs*1000);
  setDateWindow(left, now - 1000);
}

// left and right in milliseconds.
function setDateWindow(left, right) {
  // Stop the redraw callback and update them all.
  blockRedraw = true;
  for (var gi in graphs) {
    var obj = graphs[gi];
    var g = obj.g;
    g.updateOptions({'dateWindow': [left, right]});
  }
  blockRedraw = false;
}

function loadMore(secs, res) {
  console.log(first);
  var url = pollUrl(first - secs, first, res);
  console.log(url);
  update(url);
}

// from and to are in milliseconds.
function findGoodSummary(from, to, full_res) {
  var g = graphs[0].g;
  var pixels = g.getArea().w;
  var secs = (to - from) / 1000;
  var sec_per_pixel = Math.floor(secs / pixels);
  var url = "";
  if (sec_per_pixel <= 1 || full_res) {
    url = pollUrl(
        Math.floor(from / 1000),
        Math.floor(to / 1000));
  } else {
    url = pollUrl(
        Math.floor(from / 1000),
        Math.floor(to / 1000),
        sec_per_pixel + 's');
  }
  return url;
}

function loadFromZoom(full_res) {
  var g = graphs[0].g;
  var range = g.xAxisRange();
  var url = findGoodSummary(
      range[0], range[1], full_res);
  update(url);
}

function createChartEl() {
  var container = document.createElement('div');
  var graph_el = document.createElement('div');
  var legend = document.createElement('div');
  container.className = 'graph-container';
  graph_el.className = 'graph';
  legend.className = 'legend';
  container.appendChild(graph_el);
  container.appendChild(legend);
  document.getElementById('graphs').appendChild(container);
  return {container: container, graph: graph_el, legend: legend};
}

function parseOpts() {
  var path = location.hash.slice(1);
  var dash_opts = path.split('&');
  opts.dashboard = dash_opts[0];
  for (var i = 1; i < dash_opts.length; ++i) {
    var kv = dash_opts[i].split('=');
    var key = kv[0];
    var val = true;
    if (kv.length > 0) {
      val = kv.slice(1).join('=');
      if (val == 'true') val = true;
      else if (val == 'false') val = false;
    }
    opts[key] = val;
  }
  console.log(opts);

  document.getElementById('ct-update').checked = opts.live_updates;
  setupUpdates();
  document.getElementById('ct-sync-graphs').checked = opts.sync_graphs;
}

function setupTestDashboard() {
  document.getElementById('title').textContent = '#TEST#';
  var targets = [
      opts.test_metric,
  ];
  var els = createChartEl();
  mkgraph(els, targets, "test");
  finishSetup();
}

function setupDashboard() {
  document.getElementById('title').textContent = '#' + opts.dashboard;
  $.ajax({
    url: opts.graphite_url + "/dashboard/load/" + opts.dashboard,
  	dataType: 'json',
  	success: function(d) {
      for (var gi = 0; gi < d.state.graphs.length; ++gi) {
        //if (gi != 1) continue;
        var cfg = d.state.graphs[gi];
        var title = cfg[0];
        var targets = cfg[1].target;
        var els = createChartEl();
        mkgraph(els, targets, title);
      }
      finishSetup();
    },
    error: function(e) {
      console.log("error", e);
    }
  });
}

function addNamespaceToTarget(t) {
  if (opts.namespace.length > 0) {
    return opts.namespace + '*' + t;
  }
  return t;
}

function removeNamespaceFromTarget(t) {
  if (opts.namespace.length > 0) {
    return t.slice(opts.namespace.length + 1);
  }
  return t;
}

// from and to in milliseconds
function loadDates(from, to, full_res) {
  var url = findGoodSummary(from, to, full_res);
  console.log(from, new Date(from));
  console.log(to, new Date(to));

  setDateWindow(from, to);
  update(url);
}

function finishSetup() {
  if (opts.from && opts.to) {
    loadDates(
        new Date(opts.from).valueOf(),
        new Date(opts.to).valueOf(),
        opts.full_res_preload);
  } else {
    update();
  }
  toggleUpdates();
}

function shareView() {
  var url = shareUrl(true);
  document.location.hash = url;
  alert('Copy the URL. By default, this will load the timestamp ' +
      'at full resolution. If your time range is too wide, you ' +
      'may consider editing the URL before sharing it.');
}

function shareUrl(full_res) {
  var g = graphs[0].g;
  var range = g.xAxisRange();
  console.log(range);
  var from = new Date(range[0]).toISOString();
  var to = new Date(range[1]).toISOString();
  console.log(from, to);
  var url = '#' + opts.dashboard +
    '&namespace=' + opts.namespace +
    '&from=' + from + '&to=' + to;
  if (full_res) {
    url += '&full_res_preload=true';
  }
  url += '&live_updates=false';
  return url;
}

function main() {
  parseOpts();
  if (opts.is_test) {
    setupTestDashboard();
  } else {
    setupDashboard();
  }
}
main();

</script>
